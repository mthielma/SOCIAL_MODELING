\documentclass[11pt]{article}
\usepackage{geometry}                
\geometry{letterpaper}                   

\usepackage{natbib}
\usepackage{pdfpages}
\usepackage{longtable}
%\usepackage[latin1]{inputenc}
%\usepackage[english]{babel}
%\usepackage[T1]{fontenc} 

\usepackage{multirow}
\usepackage{lscape} % stellenweises Querformat TABLE

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{natbib}
\usepackage{amssymb, amsmath}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{color}
\usepackage{listings}
\setlength{\parindent}{0pt}
\sloppy


%\title{Title}
%\author{Name 1, Name 2}
%\date{date} 

\begin{document}


\input{cover}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section*{Agreement for free-download}
\bigskip


\bigskip


\large We hereby agree to make our source code for this project freely available for download from the web pages of the SOMS chair. Furthermore, we assure that all source code is written by ourselves and is not violating any copyright restrictions. We clearly state in the text, which external packages we used that were not written by ourselves. Those packages are freely available at Matlab FileExchange and are published under a BSU license. 
\begin{center}

\bigskip


\bigskip


\begin{tabular}{@{}p{3.3cm}@{}p{6cm}@{}@{}p{6cm}@{}}
\begin{minipage}{3cm}

\end{minipage}
&
\begin{minipage}{6cm}
\vspace{2mm} \large Fabio Crameri

 %\vspace{\baselineskip}

\end{minipage}
&
\begin{minipage}{6cm}

\vspace{2mm} \large Marcel Thielmann

\end{minipage}
\end{tabular}


\end{center}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\includepdf{Declaration_of_originality}
% IMPORTANT
% you MUST include the ETH declaration of originality here; it is available for download on the course website or at http://www.ethz.ch/faculty/exams/plagiarism/index_EN; it can be printed as pdf and should be filled out in handwriting


%%%%%%%%%% Table of content %%%%%%%%%%%%%%%%%

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Abstract}
Tsunamis and Flooding events are natural catastrophes that pose a threat to humans being close to water bodies at the time of the event. It is a challenge for authorities to foresee such events and provide the means to minimize the number of fatalities. In the last decade, advances in numerical modeling of pedestrian dynamics have made it possible to model such situations and to test the influence of several parameters on evacuation dynamics. In this study, we present a code that attempts to model pedestrian dynamics. This code was written entirely in MATLAB (except some external packages, which were included as mex files) in the frame of the lecture "Modelling and Simulating Social Systems with MATLAB". We present some results on the behaviour of the code using different apporaches to describe the path finding process of a pedestrian and then apply our code to an artificial model of the evacuation of a beach in the case of a rapid flooding event.

\section{Individual contributions}
As we worked together on the whole code, it is very difficult to assess who contributed most to a particular part of the code. We both wrote different function, but oftentimes a fair bit of debugging was done by the other group member. Even the log files from github does not exactly reflect the contributions of each group member, since we also worked and debugged large parts of the code together. Concerning the report, F.C. wrote most of the theoretical part and the description of the final beach evacuation simulation (he also did the analysis of those results). M.T. mainly wrote the parts concerning the shortest path algorithm and was in charge of the documentation part.  
\section{Introduction and Motivations}
Locations close to water bodies (rivers, lakes) have always been naturally preferred for human settlements, since they provide i) water, ii) food through the animals inhabiting the water body and iii) transportation ways. In earlier times the settlements were usually located at a certain distance from the water body to prevent the settlement to be seriously affected by flooding. With the increase of inhabitants, those settlements grew closer to the water body, thus making it more vulnerable to flooding events.
When a part of a city has to be evacuated because of a flooding event, it is important to have information about the social behavior of the inhabitants. Based on this information, more effective evacuation procedures can be developed that might be crucial in reducing possible fatalities.
I this project, we developed a code to simulate such events. The code is based on existing findings about the behaviour of pedestrians in crowds and was extended (inspired by the work of \citet{HeerBuehler}) to take different additional effects in to account. In this study, we tested the effects of several additions in a set of small and simple models and then applied the code to a larger domain, where we investigated the evacuation of a beach which is about to be flooded. 
\section{Description of the Model}
In the following, we describe the theory that provides the basis for our model (from \citet{Helbing2000}). The model itself is a continuous model, meaning that each pedestrian is modeled as a separate agent. The agents in our model are panically trying to derive an exit. Number, size, mass and max. velocity of each agent can be changed for different model setups. The movement of each agent is driven by a set of forces which will be described in the following. In the following, the different forces are described in relation to their origin.
\subsection{Agent Forces}
Agent forces can be divided into psychological and physical forces. Psychological forces are meant to mimic the will of each agent, whereas physical forces arise when agents actually touch each other.

\subsubsection{Psychological forces}

Except for special circumstances, people do not like to move too close to each other. This can be represented by a repulsive force of a pedestrian to another. The psychologic social forces between two agents that are not touching each other can thus be described as

\begin{equation}
	{{\bf f}_{ijS}} = \left\{ {{A_i}\exp \left[ {\frac{{\left( {{r_{ij}} - {d_{ij}}} \right)}}{{{B_i}}}} \right] } \right\}{{\bf n}_{ij}} 
		\label{eq:fijS}
\end{equation}

where $A_i$ and $B_i$ are constants, ${\bf n}_{ij} = ({\bf r}_i - {\bf r}_j)/d_{ij}$ is the normalized vector pointing from pedestrian $j$ to pedestrian $i$, $d_{ij}$ is the distance between the pedestrians center of mass and $r_i$ is the size (i.e. radius) of the pedestrian \citep{Helbing2000}. 

\subsubsection{Physical forces}

In the case of physical contact between two pedestrians, there is two forces which one has to consider for a model of the present study. There is the normal force acting between the two colliding bodies, preventing them to merge, which can be formulated as

\begin{equation}
	{{\bf f}_{ijPn}} = {kg\left( {{r_{ij}} - {d_{ij}}} \right)} {{\bf n}_{ij}}
		\label{eq:fijPn}
\end{equation}

and a tangential force between two sliding agents given by

\begin{equation}
	{{\bf f}_{ijPt}} = \kappa g\left( {{r_{ij}} - {d_{ij}}} \right)\Delta v_{ji}^t{{\bf t}_{ij}} .
		\label{eq:fijPt}
\end{equation}

Here, the function $g$ is zero if the pedestrians do not touch each other, $k$ and $\kappa$ are large constants and $\Delta v_{ji}^t = ({\bf v}_j - {\bf v}_i)\cdot {\bf t}_{ij}$ is the tangential velocity difference \citep{Helbing2000}.

When the different forces are added together, we obtain the total social force applied on an agent

\begin{equation}
	{{\bf f}_{ij}} = {{\bf f}_{ijS}} + {{\bf f}_{ijPn}} + {{\bf f}_{ijPt}} .
		\label{eq:fij}
\end{equation}

\subsection{Wall forces}

For a pedestrian panic to occur, walls are needed. They bound a certain amount of space, which might become small when filled with people. They further produce bottlenecks at positions where a room suddenly gets smaller or where there is an exit at which pedestrians are accumulated. From nature we know two main behaviors regarding walls: People usually don't like to walk too close to a wall and people can not walk through a wall. Therefore there are two forces to consider when modeling such a feature, psychologic and physical forces.

\subsubsection{Psychological forces}

The psychological repulsive force defined here for the walls/buildings can be written in mathematical terms as

\begin{equation}
	{{\bf f}_{iWS}} = \left\{ {{A_i}\exp \left[ {\frac{{\left( {{r_i} - {d_{iW}}} \right)}}{{{B_i}}}} \right]} \right\}{{\bf n}_{iW}} ,
	\label{eq:fiWS}
\end{equation}

where $A_i$ and $B_i$ are constants, $n_{iW}$ is the normalized vector pointing from the pedestrian to the wall, $d_{iW}$ is the distance in between and $r_i$ is the size (i.e. radius) of the pedestrian.

\subsubsection{Physical forces}
As in the case of physical inter-agent forces, an agent is subject to physical forces from the walls if it comes too close to a wall. The physical wall forces can be divided into a normal force $f_{iWPn}$ and a tangential force $f_{iWPt}$ acting from the wall and are written as:

\begin{equation}
	{{\bf f}_{iWPn}} = \left\{ {kg\left( {{r_i} - {d_{iW}}} \right)} \right\}{{\bf n}_{iW}}
	\label{eq:fiWPn}
\end{equation}

and

\begin{equation}
	{{\bf f}_{iWPt}} = \left\{ {\kappa g\left( {{r_i} - {d_{iW}}} \right)\left( {{{\bf v}_i} \cdot {{\bf t}_{iW}}} \right)} \right\}{{\bf t}_{iW}} ,
	\label{eq:fiWPt}
\end{equation}

respectively. Here, the function $g$ is zero if the pedestrian does not touch the wall, $k$ and $\kappa$ are large constants and $(v_i \cdot t_{iW})$ is the tangential velocity difference.

The total repulsive force from the architecture $f_{iW}$ can then be written as

\begin{equation}
	{{\bf f}_{iW}} = {{\bf f}_{iWS}} + {{\bf f}_{iWPn}} - {{\bf f}_{iWPt}} .
	\label{eq:fiW}
\end{equation}



\subsection{Exits}
\label{sec:Exits1}

In our model, the sole attractive force is the exit force. As for the social forces, it is rather a psychological force representing the will of each agent to reach the exit. In this work, we chose the value of the exit force to be proportional to the sum of the other psychological forces (in our code, one can choose a proportionality constant to adjust the exit force). To determine the direction of the exit force, we used two different approaches: i) the agent is drawn directly towards the exit, regardless of any obstacles in between him and an exit, and ii) the agent decides on its walking direction based on the estimate of the time it needs to reach the exit (e.g. \citet{HeerBuehler}).
While i) is relatively straightforward to implement, there are several crucial drawbacks to this method: First, it does not reflect at all the decision processes of a human agent, since obstacles between the agent and the exit are always taken into account. Second, this implementation might result in agents being trapped in corners, which is not realistic. For the second implementation, we used a shortest path algorithm to compute the estimated time to the exit.

\subsubsection{Shortest path formulation}
Finding the shortest path between two points is a mathematical problem that has received much attention since it's solution can be used in a huge number of applications. \citet{Sethian} presented a fast and efficient method to solve a certain class of shortest path problems, which is called the Fast marching method. It is a special case of level set methods and solves the Eikonal equation. 
In geophysics, the Eikonal equation is used to describe the propagation of a wavefront through a medium. The problem of pedestrians finding the shortest path to an exit is a very similar one. We can therefore use this method in our code to find the shortest path between an agent and the exit.

\subsection{Flood}

In model cases were we use a rising flood, another repulsive force is added. The flood will rise with time and adjust laterally depending on the local topography. Agents will try to prevent going into water, but are able to walk through it until a certain depth level.

\subsection{Pedestrian walking speed}

The free (unobstructed by obstacles) walking speed of pedestrians is determined by several factors:

\begin{enumerate}
\item the conditions of the ground
\item the situation of an agent (e.g. panic)
\item the forces acting on an agent
\end{enumerate}

In our model, we assume the conditions of the ground to be the same everywhere, meaning that there is no effect of ground roughness on the velocity of the agent. However, as we intend to include topography in our model, we introduce a walking speed function that is dependent on the slope $S$ of the ground \citep{tobler}:

\begin{equation}
	v(S) = A_{S} \exp{\left( -B_S | S + S_{crit} |  \right)}\mbox{,}
\end{equation}

where $A_S$ and $B_{S}$ represent constant factors and $S_{crit}$ is the critical slope above which a pedestrian actually slows down while walking downwards. \citet{tobler} used values of $A_S = 6$, $B_S = 3.5$ and $S_{crit} = 0.05$. On flat terrain, those parameters result in a walking speed of 5 km/h., if $A_S$ is given in units of km/h. In panic situations however, this velocity can reach values of 5-6 m/s. Here, we take this into account by varying the factor $A_S$ in the walking speed function to account for higher velocities.

To account for the impact of psychological and physical forces on pedestrian walking speed, \citet{Helbing2000} used the following equation for the change of agent velocity in time:

\begin{equation}
	\frac{d \mathbf{v}_i}{dt} = \frac{v_i^0\mathbf{e}_i - v_i(t)}{\tau_i} - \sum_{j(\ne i)}f_{iW} - \sum_{j(\ne i)}f_{iA}\mbox{,}
\end{equation}

where $v_i^0\mathbf{e}_i$ is the desired velocity in the desired direction.

\section{Implementation}\label{sec:implementation}

This section is meant to both give an overview of the methods used in this code as well as to provide a documentation of the code. Therefore, some details are mentioned here that might not be crucial for any code that simulates pedestrian dynamics, but are needed in our implementation.\\
We tried to organize the code in a modular way, each module being a separate function. We did not do that in a rigorously consequent manner, but to a large extent most of the different modules are contained in separate functions. Using a number of different switches, the user can switch on and off different modules of the code (more details on the different switches can be found in \ref{sec:input_file}).\\
The actual simulation is carried out in the main function EscapePanic.m. The structure of this function can be seen in fig.\ref{fig:EscapePanic}. 
\begin{figure}
\centering
\includegraphics[height=0.8\textheight]{figures/EscapePanic}
\caption{Flow diagram of the main simulation function EscapePanic.m. Actions that are drawn in parallel belong to an if-loop.}
\label{fig:EscapePanic}
\end{figure}
To save computation time, we decided to compute several fields (e.g. the psychological forces from buildings) on a regular grid instead of computing it individually for each agent. To get the value of the respective field for an individual agent, we then interpolated this field to the agents. We assume that by using a sufficient high resolution (0.1 m spacing) for this field, our results are sufficiently accurate. The regular grid as well as the fields are computed before we enter the time loop in our simulations (also see fig.\ref{fig:pre-loop} for a flow diagram of the pre-loop computations). Additionally, we initalize an array of structures called AGENT, in which all values related to the agents are stored. This makes is relatively easy to access the parameters for each agent. The cost of using such an array is that the assignment of values to particular fields of a structure in the array is relatively expensive in terms of computational time since it is not straightforward to vectorize operations on such an array of structures. We therefore usually had to transfer the vlaues in the fields of the different structures to vector, perform the operation on this vector, then transferring it to a cell array, which then allowed us to assign the contents of this cell array to the respective field of the structures in the AGENT array of structures. However, since other operations take much more time in our simulation, we prefer this data structure because of its accessibility.\\
\begin{figure}
\centering
\includegraphics[height=0.5\textheight]{figures/PreLoopComputations}
\caption{Flow diagram of the pre-loop computations in EscapePanic.m. Actions that are drawn in parallel belong to an if-loop.}
\label{fig:pre-loop}
\end{figure}

\subsection{Initialization of Buildings, Exits and Flood maps}
Building information is passed to the EscapePanic function as a list where the minimal and maximal x- and y-values are stored. This is feasible only when using buildings that conform to the lines of a cartesian grid. In the case of more complex building structures, this would have to be changed. From this building list, we then produce a boolean building map with a high spatial resolution, where the nodes are assigned a 1 when a building is located at the respective node and 0 when no building is located there. This building map is then later on used in several functions. The same is done for exits and a flood map.
\subsection{Agents}
The AGENT structure is initialized using a separate function, where we initialize both agent parameters such as maximal agent velocity, mass etc. and fields that will contain information about forces acting on each agent later on. Several agent parameters can be varied in a random manner. The perturbation can be set in the input file by the user. Initial agent locations are computed in a random manner inside a predefined starting area.
\subsubsection{Agent forces}
The different forces acting on the agents are computed in different functions and stored in the AGENT array of structures.
\begin{description}
\item{\textbf{Psychological forces from buildings: }}As those forces are static throughout the simulation, they are computed before the time loop on a regular grid and then interpolated to the agents at each time step. Values that have to be interpolated are the magnitude of the force and the direction of the force. The direction is again normalized after interpolation. To compute the psychological forces on the regular grid, we use the MATLAB function bwdist from the image processing toolbox, which computes the distance from a node with value 0 to a node with value 1 in a very fast manner. 
\item{\textbf{Psychological forces from the flood: }}Those forces are computed in a similar manner as the psychological forces from the buildings, but as the water level is changing at each time step, this has to be done inside the time loop.
\item{\textbf{Psychological forces from agents: }}Prior to computing those forces, a kd-tree \citep{kdtree} is created inside the time loop to allow for a fast range search of the agent locations. Inside the agent loop, we then perform this range search to find all the agents located in a box around the "active" (meaning that the forces for this agent are computed in this step of the agent loop) agent. We then compute the distance of the active agent to the agents in this box and use this information to compute the social force resulting from those agents.
\item{\textbf{Physical forces from agents: }}Using the information about the distance from the step above, we can now compute the physical force from other agents acting on the active agent, if they are too close. We can compute both the normal as well as the tangential force. In our code, the tangential force computation lead to spurious effects, which is why we switched it off in our simulations. We suspect that there is a bug in this computation (most likely a sign error), but due to the limited amount of time available, we were not able to fix this issue.
\item{\textbf{Physical forces from buildings: }}The physical forces from building on the agent are also inly computed when the agent is getting too close to a building. As for the physical forces from the agents, we omit the tangential forces.
\item{\textbf{Exit forces: }}Exit forces can be computed in this code in two different ways: Either one can set the exit force to be proportional to the other social forces acting on the agent, only that the exit force is directed towards the exit, or one can use a constant exit force. We chose to use a constant exit force for simplicity. The computation of the exit direction is described below.
\end{description}

\subsubsection{Repulsive walls}
\label{sec:WallsImplementation}
Repulsive walls are added using a list of minimum and maximum values in x- and y-direction. Therefore only square buildings are implemented in the current version of the code. The single buildings are then put together into a building map, where we calculate the distance between every free point in the model domain (not covered by a building) and the nearest wall. From this distance we calculate the psychologic wall force on all agents and, if they touch the wall, the physical wall forces as well. Eq.~\eqref{eq:fiWS} for the psychologic wall force can be rewritten as

\begin{equation}
	{f_{iWS}} = \left\{ {{A_i} {\exp \left[ {\frac{{ - {d_{iW}}}}{{{B_i}}}} \right] \cdot \exp \left[ {\frac{{{r_i}}}{{{B_i}}}} \right]} } \right\}{{\bf n}_{iW}}
	\label{eq:fiWS2}
\end{equation}
which allows for calculating the first part already before starting the time loop. The second part is then added later on in the agent loop.

\subsubsection{Exit forces}
As mentioned above, we tested several different methodes to mimic the desire of an agent to reach the exit. All methods use a shortest path algorithm which was downloaded from the Matlab File Exchange \citep{fastmarching}. We then implemented 5 different ways to compute the desired direction to the exit of an agent:
\begin{description}
\item{\textbf{Direct exit direction: }}In this case, all nodes in our domain are assigned a constant velocity $v_0$, which is equal to the unperturbed maximal velocity of the agents. Using the fast marching algorithm, we then obtain the estimated time it takes to go from each node to the exit. Taking the gradient of this field in both x- and y-direction and normalizing them yields the desired direction of the agents.
\item{\textbf{Shortest path with buildings taken into account: }} In this case, we set the velocity at the nodes where a building is located to a very small value ($10^{-8}$). Setting this value to 0 results in numerical errors, since the travel time would then become infinite at those nodes. This approach also results in an exit direction that is perpendicular to the building walls at the nodes that are part of a building wall. This is actually desirable, as it adds an additional "desire" to the agent to stay away from a wall.
\item{\textbf{Shortest path with buildings and other agents taken into account: }} We implemented this extension by reducing the velocity at the nodes, where an agent is present, by a constant factor (which can be changed by the user). To do this, we had to loop over the agents and find the nodes that are inside their radius. We were not able to vectorize this part, which is why it takes up most of the time in our simulations. It would be desirable to find a way to speed up this part of the code. Taking agents into account sometimes resulted in unrealistic exit directions, which is why we decided to overly the shortest path field with agents taking into account with a field that was computed without agents. Those two fields can be weighted in an individual manner by the user.
\item{\textbf{Shortest path with buildings,other agents and topography taken into account: }}Including the topography effect in the shortest path computation proved to be a challenge, as the slope of the terrain changes with the walking direction. The problem, we had to solve is therefore strongly nonlinear. We first tried to iterate on the solution and gradually updating the solution in every iteration step, but this did not result in satisfying results, if the iterations converged at all. Therefore, we just took five iterations, since this was sufficient to compute the relevant features of the shortest path field. As the shortest path field with the agents is anyway added to this field, the details are not of such an importance.
\item{\textbf{Shortest path with buildings,other agents,topography and flood taken into account: }}In this case, we additionally set the velocity at the nodes which were flooded to a critical extent to a minimum value.
\end{description}

\subsection{Walking speed}
The implementation of the slope-dependent walking speed is relatively straight-forward. We assumed that the slope-dependency of the velocity only applies to the maximum velocity of an agent, therefore we only reduced its maximum velocity. We are aware that this is not entirely true, but as the agents usually reach their maximum velocity very fast, we assumed that our assumption is to first order accurate. To compute the slope of the terrain, we had to project the direction of the agent onto the gradient field in x- and y-direction (which was interpolated to the agent using linear interpolation). Using eq.\eqref{eq:walking_speed}, we then computed the maximum velocity and limited the velocity of the agent resulting from eq.\eqref{eq:vel} to this velocity.

\subsection{Flooding}

The flooding is similarly implemented as the repulsive walls described in Section~\ref{sec:WallsImplementation}. The top of the water level is repulsive by a magnitude lower value than those of the walls. Agents are allowed to cross this first waterfront, if they overcome this repulsive force. In the shallow water, the desired velocity ($v_0$) is reduced to half the value than on land. Agents might go deeper and deeper into the water until there is a second waterfront at a certain water depth level (0.2 m depth). This is also a repulsive front by the same value as walls this time. If agents still cross this front, they are subsequently removed from the model and sadly declared as drowned.

\subsection{Computational efficiency of the code}

The code is highly vectorized and pushed towards high efficiency in order to be able to model a very large area including many agents in an acceptable amount of time. Although it is not parallelized, it solves computationally expensive calculations in a relatively short time. We assume that inter-agent forces are only relevant in a certain range around the agent. This assumption is justified by the fact that pedestrians only have a limited range of sight in a crowd and that they tend to focus their attention on other pedestrians nearby. We therefore assume that only psychological forces from agents in a box with five meters edge length are relevant. To determine the number of agents inside that box, we make use of a very efficient kdtree implementation found on the Matlab File Exchange. The kdtree algorithm is an algorithm that allows for fast and efficient range searches, which is why we make use of it here.
Data visualization is done separately after computation. It actually takes more time than the computation itself. Since we do not need to visualize every timestep, we did not have a significant problem with this issue.

\section{Simulation Results and Discussion}

\subsection{Model setups}

In this study, we use a set of different model setups and several different model parameters. The model setups are i) room with one door, ii) a complicated path, iii) room with one door including topography, iv) a room with two doors and finally v) large beach setup with several buildings and topography where finally a flood is included. The different cases are listed together with their model parameters in Table~\ref{tab:Parameters}. Resolution test indicate the spatial resolution of $0.1$ m is sufficient and used throughout all the model setups. A constant time step of $0.01$ s turned out to be sufficiently small and is used in all the models.

%  \newpage  %TABLE parameters

\begin{landscape}
\begin{table}  
	% \centering
	 \begin{footnotesize}
	\caption{Models and numerical setups used in this work.}
	\label{tab:Parameters}
	\begin{tabular}{l l r r  r }
	\hline
	 \textbf{Model} & \textbf{Exit force} & \textbf{perturbations} & \textbf{topography} &\textbf{flood}  \\
	 & formulation & &  \\
	 & & &  \\
	\hline
		&  \\
			&   \\
	\hline
	{\bf Model1\_direct\_1}	& direct 	& no			& no& no	\\
	{\bf Model1\_direct\_2}	& direct 	& size, mass, $\Delta f_{ijS}$ 	& no& no\\
	{\bf Model2\_direct\_1}	& direct 	& size, mass 	& no 	& no\\
	{\bf Model2\_shortest\_1}	& sh. path & size, mass 	& no 	& no\\
	{\bf EscapePanicTwoExitsDirect} & direct & mass, $\Delta f_{ijS}$ & no& no\\
	{\bf EscapePanicTwoExitsShortestPath} & sh. path & mass, $\Delta f_{ijS}$ & no& no\\
	{\bf EscapePanicTwoExitsShortestPathAgent} & sh. path ag. & mass, $\Delta f_{ijS}$ & no& no\\
	{\bf EscapePanicTwoExitsShortestPathAgentTopo} & sh. path ag. top. & mass, $\Delta f_{ijS}$ & yes& no\\
	{\bf BeachRun5} & sh. path ag. top. & size, $v_0$, mass, $\Delta f_{ijS}$  & yes & yes\\
	{\bf BeachRun6} & sh. path ag. top. & size, $v_0$, mass, $\Delta f_{ijS}$  & yes  & yes\\
	{\bf BeachRun7} & sh. path ag. top. & size, $v_0$, mass, $\Delta f_{ijS}$  & yes  & yes\\
	{\bf BeachRun8} & sh. path ag. top. & size, $v_0$, mass, $\Delta f_{ijS}$ &  yes & yes\\
	\hline
	\end{tabular}
	
	{\bf sh. path:} shortest path formulation / {\bf sh. path ag.:} shortest path formulation with agents / {\bf sh. path ag. top.:}\\ shortest path formulation with agents and topography  \\
	\end{footnotesize}
\end{table}
\end{landscape}



\subsection{Simple evacuation bottleneck: One exit}

\subsubsection{Direct exit force}

\begin{figure}
	\begin{center}
	\includegraphics[width=0.6\textwidth]
	{figures/Model1_direct_1b_000000.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model1_direct_1b_000550.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model1_direct_1b_001800.eps}
	\caption{Time evolution of simple starting model for a room evacuation through a bottleneck. Initial setup (top), agents arriving at the bottleneck and accumulating in behind (middle) and agents blocking each other of exiting at the end of the simulation (bottom).}
	\label{fig:simple1}
	\end{center}
\end{figure}

The simplest version of our code has one exit (Fig.~\ref{fig:simple1}). The attractive force on the agents is defined to be linear towards the exit, thereby neglecting obstacles in between. The agents will not move towards an opening in an obstacle but toward the exit itself. Moreover, this formulation inhibits the agents of running around a bigger obstacle. This is a strong simplification but suitable to test the code. The behavior of the agents towards the repulsive walls and towards each other is satisfactory.

A first case ({\it Model1\_linear\_1}) is shown in Fig.~\ref{fig:simple1}. The model setup consists of a $15\times9$ m room that is bounded by repulsive walls. A $1\times1$ m door is the only exit thereof and leads to the attractive main exit of the model. The agents are initially placed randomly in an $3.5\times7$ m area in the left hand side of the domain (Fig.~\ref{fig:simple1}b). The model is not satisfactory, because at the late stage of evacuation there are two agents opposite of each other preventing them to exit the room (Fig.~\ref{fig:simple1}c). The counter parting psychologic social forces cancel all other forces out and therefore both agents remain at their position.

\begin{figure}
	\begin{center}
	\includegraphics[width=0.6\textwidth]
	{figures/Model1_direct_2b_000000.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model1_direct_2b_000550.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model1_direct_2b_001800.eps}
	\caption{Time evolution of model including perturbations for a room evacuation through a bottleneck. Initial setup (top), agents arriving at the bottleneck and accumulating in behind (middle) and agents blocking each other of exiting at the end of the simulation (bottom).}
	\label{fig:simple2}
	\end{center}
\end{figure}

In order to introduce some noise into an otherwise perfect model we added several perturbations ({\it Model1\_linear\_2}). The psychologic social force between the agents is perturbed by a random small value in the order of $\pm 0.05$ N. Another complexity is added by characterizing the different agents. Accounting for different appetite and/or stomach behavior, their mass is randomly chosen with a perturbation of $\pm 10$ kg. A bigger radius is subsequently needed for fulfilling mass conservation. Therefore the agent's radius is randomly perturbed by $\pm 0.05$ m. The results of these adjustments are shown in Fig.~\ref{fig:simple2}.

Still the last two pedestrians are disabled of leaving the room because of the counteracting forces they exert on each other. This shows, that the "perfectness" of the model was not the main problem of this occurrence. The main cause of it might be found in the way the attractive exit force is described. The agents are pulled with the exit force directly towards the position of the exit, neglecting possible obstacles in between. Hence, in the case of the two blocked pedestrians, the main force is directed perpendicular to the wall instead of tangential to the wall towards the wall door. The force in this direction is very small and can thus easily be overweighted by the repulsive social force of the opposite agent. The agent is kept at his current position.

A solution of this problem therefore might be found in a different description of the attractive exit force by e.g. using a shortest path formulation.

\subsubsection{Shortest path formulation}

The shortest path formulation as described in Section~\ref{sec:Exits1} can improve the nature-like behavior of the model dramatically. A new setup is chosen to illustrate this and shown in Fig.~\ref{fig:simple3} and~\ref{fig:simple4}.

\begin{figure}
	\begin{center}
	\includegraphics[width=0.6\textwidth]
	{figures/Model2_direct_1b_000000.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model2_direct_1b_000350.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model2_direct_1b_001800.eps}
	\caption{Time evolution of model with direct exit force formulation for a pedestrian flow around complicated architecture. Initial setup (top), agents arriving at the barrier walls and accumulating  (middle) and agents getting stuck and not able to move around an obstacle at the end of the simulation (bottom).}
	\label{fig:simple3}
	\end{center}
\end{figure}

The walls are placed in a way that the pedestrians have to move around corners and even away from the exit to finally arrive there. This is not straight forward and a simple exit force formulation is not able to describe the pedestrian flow in such a case (Fig.~\ref{fig:simple3}). The Agents get captured by obstacles with no direct passage towards the exit and are not able to leave such a place. 

The more elaborated shortest path formulation, on the other hand, can describe such a more complicated pedestrian flow in a realistic manner (Fig.~\ref{fig:simple4}). The agents are able to see all possible passages towards an exit in the whole model and are therefore able to choose the fastest way.

\begin{figure}
	\begin{center}
	\includegraphics[width=0.6\textwidth]
	{figures/Model2_fastest_1_000000.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model2_fastest_1_000270.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]
	{figures/Model2_fastest_1_000410.eps}
	\caption{Time evolution of model including shortest path formulation for a pedestrian flow around complicated architecture. Initial setup (top), agents moving closely around corners (middle) and agents able to move around obstacles in the fastest way and arriving the exit at the end of the simulation (bottom).}
	\label{fig:simple4}
	\end{center}
\end{figure}

\subsection{Simple evacuation bottleneck: Two exits}

As we saw in the one-exit models, the shortest path formalism led to a more realistic behaviour of the agents. In a second step, we now extended the model by introducing one additional exit, leaving out the additional obstacles. In a first step, we used the shortest path procedure to determine the desired direction of the agent. As this did not lead to the desired agent behaviour (see Section~\ref{sec:two_exits1}), we had to extend the shortest path procedure by additionally taking agents into account (the procedure is described in Section~\ref{sec:implementation}). This led to a significant improvement in agent behaviour. As we additionally have to deal with topography in our model, we then introduced a small topography in our model to assess its effect on agent behaviour. In the three following subsection, we shortly show and discuss the results of the different setups.

\subsubsection{Shortest path exit force}\label{sec:two_exits1}

Here, the exit direction of the agents is given by the shortest path algorithm, which has proven to yield better results compared to the direct path approach. Instead of having one gap in the wall as before, we now have two gaps in the wall. Additionally, the exit was switched slightly towards the lower gap. This makes the lower gap more preferable, since the path to the exit through this gap is shorter.

As one can see in Fig.~\ref{fig:two_exits1}, the shortest path algorithm results in a rather unrealistic behaviour of the agents: Instead of opting for the upper gap in case the lower gap is blocked by other agents, all agents choose the lower gap.

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{figures/TwoExitsShortestPath_000050.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]{figures/TwoExitsShortestPath_001550.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]{figures/TwoExitsShortestPath_001900.eps}
	\caption{Snapshots of the time evolution of a simple two-exit model using the shortest path algorithm to determine the exit direction. As can be seen, the simple shortest path formalism doesn't work in a realistic manner, since all the agents opt for the closest exit regardless of other agents blocking the way. For a better illustration, we chose one agent (named Don) and plot his path through the model domain. As one can see, Don never changes his direction on the way to the exit.}
	\label{fig:two_exits1}
\end{figure}

This behaviour is clearly not what one could observe in reality, since at least some agents would prefer the upper gap and reach the exit significantly faster than in our simulation. We therefore had to adjust the shortest path procedure to account for agents blocking the way.
\subsubsection{Shortest path exit force with agents taken into account}
In the second simulation, we used the extended shortest path procedure to determine the exit direction of the agents. We tried different combinations of the sensitivity of the agents to other agents blocking the way. The (in our opinion) best results were obtained when we reduced the estimated velocity at a node by a factor of 2.5. In Fig.~\ref{fig:two_exits2}, it can be seen that the behaviour of the agents is much more realistic than before. In this simulation, agents frequently re-decide on the path to be taken and change from the lower to the upper gap or vice versa if either of those gaps is blocked.

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{figures/TwoExitsShortestPathWithAgents_000650.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]{figures/TwoExitsShortestPathWithAgents_001350.eps}
	\qquad
	\includegraphics[width=0.6\textwidth]{figures/TwoExitsShortestPathWithAgents_002300.eps}
	\caption{Snapshots of the time evolution of a simple two-exit model using the shortest path algorithm to determine the exit direction. In this case, agents blocking the way to the exit are taken into account. This enables the agents to redecide on the path taken to the exit depending on the agent density in between. The path of our example agent Don clearly shows this process. At first, Don chooses a path that keeps him in between both exits due to the agents in front of him. Then, as crowding at the lower exit occurs, he decides to go towards the upper exit, but then redecides as the lower exit becomes less crowded again.}
	\label{fig:two_exits2}
\end{figure}

\subsubsection{Shortest path exit force with agents and topography taken into account}

In this last simulation, we tested the influence of topography on agent behaviour. For this reason, we introduced a slight topography in our model. The topography is essentially a two-dimensional Gaussian curve, which is given by the equation:

\begin{equation}
	z(x,y) = A\exp \left(- \frac{\left(x-x_0\right)^2}{2\sigma_x} + \frac{\left(y-y_0\right)^2}{2\sigma_y}\right)
\end{equation}

In this simulation, we chose $A = 1 $ m, $x_0 = 10$ m, $y_0 = 5$ m, $\sigma_x = 15$ m and $\sigma_y = 6$ m.

\subsection{Evacuation of a beach in the case of a tsunami event}

\begin{figure}
	\centering
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth7_Flood0_1_000000.eps}
		\qquad
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth7_Flood0_1_006300.eps}
	\caption{Initial condition of the beach evacuation model: 1000 pedestrians (yellow circles) swimming or lying in the sun (top). Final stage of evacuation model: last surviving pedestrian arrives at exit just before the flood reaches him. Black squares indicating beach houses or anti-flood wall, green square is the exit, grey contours indicating topography and blue contour indicates water covered surface for shallow (cyan) and deep water (dark blue), respectively.}
	\label{fig:beach_initial}
\end{figure}

Fig.~\ref{fig:beach_initial} shows the initial model setup that consists of $55\times110$ m wide box, several beach houses and a anti-flood wall in the back including a relatively wide exit. Topography is included in this setup shown by the topography contours. This is needed for a flood to rise over time until the water reaches the only exit of the model. One thousand people are initially placed at the beach close to the water (or in the water). At the model start, the flood starts to rise and the people immediately start to panically escape the beach area towards the exit. The beach houses in between hinder them (depending on the model setup) to do so in a sufficiently short time. The goal of this setup is to evaluate the escape possibilities from the beach depending on the width of the streets between each house parcel. Therefore we here present four different models using different parcel spacings.

\begin{figure}
	\centering
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth7_Flood0_1_000700.eps}
	\qquad
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth7_Flood0_1_002000.eps}
	\caption{Wide beach house setup: different time steps show the approach of the flood and the escaping pedestrians.}
	\label{fig:beach_1}
\end{figure}

Fig.~\ref{fig:beach_1} shows the model evolution using a wide parcel spacing of 7 m. In this experiment, pedestrians do not have problems in escaping the rising flood: Their escape path is very easy and thus also sufficiently short. People do not accumulate to much, because there are no dramatic bottlenecks.

\begin{figure}
	\centering
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth5_Flood0_1_000700.eps}
	\qquad
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth5_Flood0_1_002000.eps}
	\caption{Intermediate beach house setup: different time steps show the approach of the flood and the escaping pedestrians.}
	\label{fig:beach_2}
\end{figure}

A slightly denser setup is shown in Fig.~\ref{fig:beach_2}. The spacing between two adjacent parcels is here 5 m wide. People again seem to be able to escape well.

\begin{figure}
	\centering
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth3_Flood0_1_000700.eps}
	\qquad
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth3_Flood0_1_002000.eps}
	\caption{Narrow beach house setup: different time steps show the approach of the flood and the escaping pedestrians.}
	\label{fig:beach_3}
\end{figure}

Fig.~\ref{fig:beach_3} presents an experiment with a narrow 3 m spacing between each house parcel. The pedestrians coming from the wide beach start to accumulate slightly at the house fronts in order to escape through the narrow paths. This slightly reduces the escape efficiency of this model.

\begin{figure}
	\centering
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth1_Flood0_1_000700.eps}
	\qquad
	\includegraphics[width=1.1\textwidth]{figures/BeachEvacuationOneExitStreetWidth1_Flood0_1_002000.eps}
	\caption{Very narrow beach house setup: different time steps show the approach of the flood and the escaping pedestrians.}
	\label{fig:beach_4}
\end{figure}

Finally, the model setup with the narrowest house spacing (1 m between adjacent parcels) is shown in Fig.~\ref{fig:beach_4}. People now dramatically start to accumulate and the entering of the streets from the beach starts to become a bottleneck. Since the pedestrians are sensitive to the accumulation of a lot of people, they start to re-decide their exit path and try to find other ways out. This leads to a dense flow of people running on the beach parallel to the beach front until they eventually decide to head into a narrow street. This effectively hinders fast evacuation and hence, many people are caught by the rising water.

\begin{figure}
	\centering
	\includegraphics[width=1.1\textwidth]{figures/AnalysisMULTI_BeachEvacuationOneExitStreetWidth1_Flood0_1.eps}
	\caption{Escape efficiency for the different model setups. (a) Wide model setup with a street width of 7 m, (b) intermediate model setup with a street width of 5 m, (c) narrow model setup with a street width of 3 m and (d) extremely narrow model setup with a street width of 1 m. Curves show cumulative amount of people arrived at the exit (blue) or drowned in the flood (red) and the total of both (black).}
	\label{fig:analysis_1}
\end{figure}

To decide on the amount of buildings per beach area it is useful to look at the number of people that are able to exit the area in a sufficient short amount of time. This is done in Fig.~\ref{fig:analysis_1}, where the cumulative amount of people is plotted that are either able to exit the model domain or that are caught by the flood. Important is here the number of persons that are able to leave in a certain amount of time. The values are marked in Fig.~\ref{fig:analysis_1}, which shows decreasing values from 41 exits per time down to 18 exits per time by increasing the density of the house parcels. The amount of exits per time in the very dense model is so low, that a dramatical amount of people are drowned in the flood.

This leads us to the conclusion that the house parcel spacing needs to be larger than 1 m and can be as narrow as 3 m to guarantee economical prosperity that goes along with tourist safety.


\section{Summary and Outlook}

In this work we present an efficient numerical code that solves pedestrian flow and panic behaviour for large scale model setups as well as for a big number of agents. The model accuracy is benchmarked using a set of small model setups. Finally, the code is used give guidance in deciding about the beach house parcel spacing close to a beach. This is done by considering a possible flooding (i.e. rise of water level) and the subsequently upcoming escape panic. Parcel spacings of 3 m are shown to be sufficient, whereas a spacing of only 1 m leads to many dead people caused by the flood.

Still there are numerical issues which might be solved in future. The shortest path formulation that takes the position of the agents into account might be improved. It is not realistic, that one agent knows the positions of all the other pedestrians in the whole model domain, nor will he be able to decide physically correct on the shortest path in reality. On the other hand, numerical experiments like those presented in this study have to be taken into account in a decision process rather than considered as true nature. Thus, numerical models in social study might prevent many dramatic events in future and possibly already have done so.

\section{References}

\bibliographystyle{plainnat}
\bibliography{socialmodelling}


\begin{appendix}
\section{Code structure and source code}
In fig.\ref{fig:EscapePanic}., the basic structure of our code is shown. We split the code description in several different parts to provide a bit more readability. In principle, we tried to put most of the computations in separate functions. The input data and parameters necessary to run the simulation are all set in a separate input file, which then calls the actual simulation function. Rather than plotting the results "on the fly", the necessary data is saved regularly. Visualization is done in an postprocessing step.
\subsection{Input file}\label{sec:input_file}
In our input file, the user can set all the parameters that are needed. In tab.\ref{tab:input} and \ref{tab:input2}, we list all parameters that can be varied in the code, the  parameters we used and their effect.

\begin{table}
\begin{tabular}{l l l}
\hline
\textbf{Input parameter} & \textbf{value} & \textbf{meaning/effect}\\  
\hline
Parameter.Foldername & 'test' & name of the output folder\\
Parameter.Save & boolean & save output files or not\\
Parameter.SaveTimeStep & 10 & saves output every $n$ timesteps\\
Parameter.Resolution & 0.1 & resolution of the regular grid \\
Parameter.maxtime & 10 &maximum simulation time (in min)\\
Parameter.dt & 0.01 & simulation timestep\\
Parameter.nagent & 20-1000 & number of agents\\
Parameter.AgentSetup &random,given,load& determines the initial agent location\\
Parameter.m & 80 & agent mass in kg\\
Parameter.m\_pert & 10 & agent mass perturbation\\
Parameter.v & 5 & agent max velocity in m/s\\
Parameter.v\_pert & 5 & velocity perturbation\\
Parameter.t\_acc & 0.5 & acceleration time in s\\
Parameter.AgentSize & 0.25 & agent radius in m\\
Parameter.AgentSize\_pert & 0.05 & agent radius perturbation\\ 
Parameter.BoxSize\_pert & 5 & box size around agent\\ 
Parameter.PhysicalForces & boolean & switch physical forces on/off\\
Parameter.Tangential & boolean & switch tangential forces on/off\\
Parameter.k & 1.2e5 & phys. normal force prefactor\\
Parameter.kappa & 2.4e5 & phys. tangential force prefactor\\
Parameter.SocialForces & boolean & switch social forces on/off\\
Parameter.pert\_social & 0.05 & percentage of social force perturbation\\
Parameter.A & 2e3 & social force prefactor\\
Parameter.B & 0.08 & social force exponential factor\\
Parameter.ExitFactor & 1  & exit force prop. factor \\
Parameter.ExitForce & constant,proportional & constant or proportional exit force\\

\hline

\hline
\end{tabular}
\label{tab:input}
\caption{Input parameters for EscapePanic.m Part 1}
\end{table}


\begin{table}
\begin{tabular}{l l l}
\hline
\textbf{Input parameter} & \textbf{value} & \textbf{meaning/effect}\\  
\hline
Parameter.WithFlood & boolean & switch flooding on/ off\\
Parameter.z0\_flood & 0 & initial water height\\
Parameter.dzdt\_flood & 0.1 & rising rate\\
Parameter.dangerousDepth & 0.2 & if water depth is greater, agents drown\\
Parameter.FloodSpeed & $v_0/2$ & max velocity of agents in water\\
Parameter.A\_flood & 5e2 & social force parameter for flood\\
Parameter.B\_flood & 0.08 & social force parameter for flood\\ 
Parameter.DirectExitPath & boolean & use direct exit direction or not?\\
Parameter.orig\_sensitivity & 1 & sensitivity of agent to exit direction\\
& & without agents\\
Parameter.agent\_sensitivity & 2.5 & sens. of agents to others in the way\\
Parameter.topo\_sensitivity & 1 & not used anymore\\
Parameter.decision\_time & 0.05 & recompute shortest path after this time\\
Parameter.WithAgents & boolean & take agents into account?\\
Parameter.WithTopo & boolean & take topo into account?\\
Parameter.Enlarge & 0.3 & building enlargement \\
Parameter.Topo\_name & none,name & topo file to be used\\
Parameter.slope\_f & 3.5&factor for slope-dependent vel.\\
Parameter.slope\_crit & 0.05 & factor for slope-dependent vel.\\
Parameter.xmin & 0 & domain boundaries\\
Parameter.xmax & 20 - 50\\
Parameter.ymin & 0 \\
Parameter.ymax & 10-150\\

\hline

\hline
\end{tabular}
\label{tab:input2}
\caption{Input parameters for EscapePanic.m Part 2}
\end{table}
\begin{landscape}
\include{RunEscapePanic}
\end{landscape}

\subsection{Beach evacution runs: Input file}\label{sec:input_file}
For the beach evacuation runs, we used two functions to create the building list and the topography. In the following, we list one example input file for the beach runs and the two additional functions.
\begin{landscape}
\include{BeachRun1}
\include{CreateTopo}
\include{SetBuildings}
\end{landscape}
\subsection{Simulation function}
The simulation function that is called by the input file runs the entire simulation, saves the output and plots intermediate results if desired. Before entering the time loop, a number of actions is performed (see fig.\ref{fig:pre-loop}). The computation of all forces that do not change throughout the simulation is done here. After the pre-loop stage, we enter the time loop. In here, we perform a number of computations for all agents, before entering an agent loop, in which we compute individual and agent-specific parameters (see fig.\ref{fig:EscapePanic}). After completing the time loop, some parameters for later analysis are save and the function exits. 

Source code files are listed in the order of their appearance.
\begin{landscape}
\include{SourceCode/EscapePanic}
\include{SourceCode/InitializeAgents}
\include{SourceCode/ArchitectureForceV2}
\include{SourceCode/ComputeShortestPathDirect}
\include{SourceCode/ComputeShortestPathGlobal}
\include{SourceCode/ComputeShortestPathGlobalTopo}
\include{SourceCode/ComputeSocialForcesStatic_flood}
\include{SourceCode/ComputeSocialForcesStatic}
\include{SourceCode/ComputeShortestPathGlobalWithAgents}
\include{SourceCode/ComputeShortestPathGlobalWithAgentsFlood}
\include{SourceCode/GetSurroundingAgents}
\include{SourceCode/ComputeDistanceToAgents}
\include{SourceCode/ComputeSocialForcesDynamic}
\include{SourceCode/ComputePhysicalForceAgents}
\include{SourceCode/ComputePhysicalForceWalls}
\include{SourceCode/ComputeExitForce}
\include{SourceCode/MoveAgents}
\include{SourceCode/CheckAgentsInBuildings}
\end{landscape}

\subsection{Visualization}
The results can be visualized in a number of ways. In this section, we list the source code of the plotting functions we used.
\begin{landscape}
\include{SourceCode/plotOutput}
\include{SourceCode/PlotFlood}
\include{SourceCode/PlotBuildings}
\include{SourceCode/PlotAgents}
\include{SourceCode/PlotTopography3D}
\include{SourceCode/PlotAgents3D}
\include{SourceCode/CreateSphere}
\include{SourceCode/PlotBuildings3D}
\end{landscape}
\end{appendix}

\end{document}  



 
